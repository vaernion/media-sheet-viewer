{"version":3,"sources":["utils/utilities.ts","classes/Creator.ts","utils/regex.ts","classes/Film.ts","classes/Game.ts","classes/Television.ts","components/Store/mediaSheet.ts"],"names":["normalize","str","replace","toLowerCase","compareLastName","a","b","arrA","split","arrB","length","localeCompare","formatYear","media","type","seasons","yearStart","yearEnd","String","year","isMedia","mediaType","getCreations","name","mediaSheet","cFilms","filmsSorted","yearDesc","filter","e","creator","includes","cTv","tvSorted","yearStartDesc","cGames","gamesSorted","capitalizeFirstLetter","string","charAt","toUpperCase","slice","Creator","id","this","count","splitRegex","RegExp","Film","film","translatedTitle","sortTitle","genre","franchise","director","push","trim","Number","filmsJson","map","films","sortedFilms","sorts","sort","bool","sortFilms","sortBy","isDescending","algorithm","pop","array","reverse","Game","game","completed","system","developer","gamesJson","games","sortedGames","sortGames","Television","tvSeries","minutesTotal","title","reduce","sum","season","seasonMinutes","tvJson","tvSeasons","parseTvEntry","Array","from","Set","tvSeason","filteredSeasons","rawSeason","episodes","episodeMinutes","tv","parseInt","sortedTv","sortTv","generateFilmsFromJson","x","i","findIndex","generateSortedFilms","directorsMatrix","directors","flat","generateTvFromJson","generateSortedTv","generateGamesFromJson","generateSortedGames","tvCreatorsMatrix","tvCreators","filmAndTvCreators","gameDevelopersMatrix","gameDevelopers","creators"],"mappings":"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","file":"static/js/0.a8488207.chunk.js","sourcesContent":["import { Creator } from \"../classes/Creator\";\nimport { Film } from \"../classes/Film\";\nimport { Game } from \"../classes/Game\";\nimport { Television } from \"../classes/Television\";\nimport { MediaSheet } from \"../components/Store/mediaSheet\";\n\nexport const normalize = (str: string) => {\n  return str\n    .normalize(\"NFD\")\n    .replace(/[^\\w\\s.-_/]/g, \"\")\n    .toLowerCase();\n};\n\nexport const compareLastName = (a: string, b: string) => {\n  const arrA = a.split(/\\s+/);\n  const arrB = b.split(/\\s+/);\n  a = arrA[arrA.length - 1];\n  b = arrB[arrB.length - 1];\n  return a.localeCompare(b);\n};\n\nexport const formatYear = (media: Film | Television | Game | Creator) => {\n  if (media.type === \"tv\" && \"seasons\" in media) {\n    return `(${media.seasons[0].yearStart}-${\n      media.seasons[media.seasons.length - 1].yearEnd\n    })`;\n  } else if (\"year\" in media) {\n    return String(media.year);\n  } else {\n    return null;\n  }\n};\n\nexport const isMedia = (mediaType: string) => {\n  return mediaType !== \"creator\";\n};\n\nexport const getCreations = (name: string, mediaSheet: MediaSheet) => {\n  let cFilms = mediaSheet.filmsSorted.yearDesc.filter((e) =>\n    e.creator.includes(name)\n  );\n  let cTv = mediaSheet.tvSorted.yearStartDesc.filter((e) =>\n    e.creator.includes(name)\n  );\n  let cGames = mediaSheet.gamesSorted.yearDesc.filter((e) =>\n    e.creator.includes(name)\n  );\n  return [...cFilms, ...cTv, ...cGames];\n};\n\nexport const capitalizeFirstLetter = (string: string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n","export class Creator {\n  static count: number = 0;\n\n  id: number;\n  type: string;\n  name: string;\n\n  constructor(name: string) {\n    this.id = Creator.count += 1;\n    this.type = \"creator\";\n    this.name = name;\n  }\n}\n","export const splitRegex = new RegExp(/[&,/|]+|\\band\\b/);\n","import { splitRegex } from \"../utils/regex\";\n\ntype FilmJson = {\n  [key: string]: string;\n};\ntype SortedFilms = {\n  [key: string]: Film[];\n};\n\nexport class Film {\n  static count: number = 0;\n  static sorts: string[] = [\"sortTitle\", \"year\", \"director\", \"franchise\"];\n\n  id: number;\n  type: string;\n  name: string;\n  translatedTitle: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  year: number;\n  franchise: string;\n\n  constructor(film: FilmJson) {\n    this.id = Film.count += 1;\n    this.type = \"film\";\n    this.name = film[\"Original title (romanized)\"];\n    this.translatedTitle = film[\"This release's translation/title\"];\n    this.sortTitle = film[\"Sort\"];\n    this.creator = [];\n    for (let director of film[\"Director(s)\"].split(splitRegex)) {\n      this.creator.push(director.trim());\n    }\n    this.genre = [];\n    for (let genre of film[\"Genres\"].split(splitRegex)) {\n      this.genre.push(genre.trim());\n    }\n    this.year = Number(film[\"Year\"]);\n    this.franchise = film[\"Series/Universe\"];\n  }\n\n  static generateFilmsFromJson(filmsJson: FilmJson[]): Film[] {\n    return filmsJson.map((film) => new this(film));\n  }\n\n  static generateSortedFilms(films: Film[]): SortedFilms {\n    const sortedFilms: SortedFilms = {};\n\n    for (let sort of this.sorts) {\n      for (let bool of [true, false]) {\n        sortedFilms[`${sort}${bool ? \"Desc\" : \"Asc\"}`] = this.sortFilms(\n          [...films],\n          sort,\n          bool\n        );\n      }\n    }\n\n    return sortedFilms;\n  }\n\n  static sortFilms(\n    films: Film[],\n    sortBy: string,\n    isDescending: boolean\n  ): Film[] {\n    let algorithm: ((a: any, b: any) => number) | null = null;\n\n    // title A-Z\n    if (sortBy === \"sortTitle\") {\n      algorithm = (a, b) => a.sortTitle.localeCompare(b.sortTitle);\n      // year 1900-2000\n    } else if (sortBy === \"year\") {\n      algorithm = (a, b) => a.year - b.year;\n      // director A-Z by last name of first director\n    } else if (sortBy === \"director\") {\n      algorithm = (a, b) => {\n        a = a.creator[0].split(/\\s+/).pop();\n        b = b.creator[0].split(/\\s+/).pop();\n        return a.localeCompare(b);\n      };\n      // franchise, entries without franchise always last\n    } else if (sortBy === \"franchise\") {\n      // franchise A-Z\n      if (!isDescending) {\n        algorithm = (a, b) => {\n          if (a.franchise === \"\") return 1;\n          if (b.franchise === \"\") return -1;\n          return a.franchise.localeCompare(b.franchise);\n        };\n        // franchise Z-A\n      } else {\n        algorithm = (a, b) => {\n          if (a.franchise === \"\") return 1;\n          if (b.franchise === \"\") return -1;\n          return b.franchise.localeCompare(a.franchise);\n        };\n      }\n    }\n\n    if (!algorithm) return films;\n\n    // sort ascending (and descending if franchise)\n    let array = [...films].sort(algorithm);\n\n    // for all except franchise we can just reverse to get descending\n    if (isDescending && [\"sortTitle\", \"year\", \"director\"].includes(sortBy)) {\n      array = array.reverse();\n    }\n\n    return array;\n  }\n}\n","import { splitRegex } from \"../utils/regex\";\n\ntype GameJson = {\n  [key: string]: string;\n};\ntype SortedGames = {\n  [key: string]: Game[];\n};\n\nexport class Game {\n  static count: number = 0;\n  static sorts: string[] = [\n    \"sortTitle\",\n    \"year\",\n    \"developer\",\n    \"completed\",\n    \"system\",\n  ];\n\n  id: number;\n  type: string;\n  name: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  year: number;\n  completed: string;\n  system: string;\n\n  constructor(game: GameJson) {\n    this.id = Game.count += 1;\n    this.type = \"game\";\n    this.name = game[\"Title\"];\n    this.sortTitle = game[\"Sort\"];\n    this.creator = [];\n    for (let developer of game[\"Developer(s)\"].split(splitRegex)) {\n      this.creator.push(developer.trim());\n    }\n    this.genre = [];\n    for (let genre of game[\"Genres\"].split(splitRegex)) {\n      this.genre.push(genre.trim());\n    }\n    this.year = Number(game[\"Year\"]);\n    this.completed = game[\"completed?\"] || \"no\";\n    this.system = game[\"System\"];\n  }\n\n  static generateGamesFromJson(gamesJson: GameJson[]): Game[] {\n    return gamesJson.map((game) => new this(game));\n  }\n\n  static generateSortedGames(games: Game[]): SortedGames {\n    const sortedGames: SortedGames = {};\n\n    for (let sort of this.sorts) {\n      for (let bool of [true, false]) {\n        sortedGames[`${sort}${bool ? \"Desc\" : \"Asc\"}`] = this.sortGames(\n          [...games],\n          sort,\n          bool\n        );\n      }\n    }\n\n    return sortedGames;\n  }\n\n  static sortGames(\n    games: Game[],\n    sortBy: string,\n    isDescending: boolean\n  ): Game[] {\n    let algorithm: ((a: any, b: any) => number) | null = null;\n\n    // title/completed/system A-Z\n    if (\n      sortBy === \"sortTitle\" ||\n      sortBy === \"completed\" ||\n      sortBy === \"system\"\n    ) {\n      algorithm = (a, b) => a[sortBy].localeCompare(b[sortBy]);\n      // year 1900-2000\n    } else if (sortBy === \"year\") {\n      algorithm = (a, b) => a.year - b.year;\n      // developers A-Z by first dev\n    } else if (sortBy === \"developer\") {\n      algorithm = (a, b) => {\n        a = a.creator[0];\n        b = b.creator[0];\n        return a.localeCompare(b);\n      };\n    }\n\n    if (!algorithm) return games;\n\n    // sort ascending\n    let array = [...games].sort(algorithm);\n\n    // reverse to get descending\n    if (isDescending && this.sorts.includes(sortBy)) {\n      array = array.reverse();\n    }\n\n    return array;\n  }\n}\n","import { splitRegex } from \"../utils/regex\";\n\ntype TvJson = {\n  [key: string]: string;\n};\ntype RawSeason = {\n  title: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  season: number;\n  yearStart: number;\n  yearEnd: number;\n  episodes: number;\n  episodeMinutes: number;\n};\ntype TvSeason = {\n  season: number;\n  yearStart: number;\n  yearEnd: number;\n  episodes: number;\n  episodeMinutes: number;\n  seasonMinutes: number;\n};\ntype TvSeries = {\n  title: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  seasons: TvSeason[];\n};\ntype SortedTv = {\n  [key: string]: Television[];\n};\n\nexport class Television {\n  static count: number = 0;\n  static sorts: string[] = [\"sortTitle\", \"yearStart\", \"yearEnd\", \"creator\"];\n\n  id: number;\n  type: string;\n  name: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  seasons: TvSeason[];\n  minutesTotal: number;\n\n  constructor(tvSeries: TvSeries) {\n    this.id = Television.count += 1;\n    this.type = \"tv\";\n    this.name = tvSeries.title;\n    this.sortTitle = tvSeries.sortTitle;\n    this.creator = tvSeries.creator;\n    this.genre = tvSeries.genre;\n    this.seasons = tvSeries.seasons;\n    this.minutesTotal = Number(\n      this.seasons.reduce((sum, season) => sum + season.seasonMinutes, 0)\n    );\n  }\n\n  static generateTvFromJson(tvJson: TvJson[]): Television[] {\n    // every season from json\n    const tvSeasons = tvJson.map(this.parseTvEntry);\n    // unique names of series\n    const tvNames = Array.from(\n      new Set(tvSeasons.map((tvSeason) => tvSeason.title))\n    );\n\n    return tvNames.map((name) => {\n      // seasons of named series\n      let filteredSeasons = tvSeasons.filter(\n        (tvSeason) => tvSeason.title === name\n      );\n\n      // used as class constructor argument\n      let tvSeries: TvSeries = {\n        title: name,\n        sortTitle: filteredSeasons[0].sortTitle,\n        creator: filteredSeasons[0].creator,\n        genre: filteredSeasons[0].genre,\n        seasons: filteredSeasons.map((rawSeason) => ({\n          season: rawSeason.season,\n          yearStart: rawSeason.yearStart,\n          yearEnd: rawSeason.yearEnd,\n          episodes: rawSeason.episodes,\n          episodeMinutes: rawSeason.episodeMinutes,\n          seasonMinutes: rawSeason.episodes * rawSeason.episodeMinutes,\n        })),\n      };\n\n      return new this(tvSeries);\n    });\n  }\n\n  static parseTvEntry(tv: TvJson): RawSeason {\n    return {\n      title: tv[\"Original title\"],\n      sortTitle: tv[\"Sort\"],\n      creator: tv[\"Creator(s)\"].split(splitRegex).map((name) => name.trim()),\n      genre: tv[\"Genres\"].split(splitRegex).map((name) => name.trim()),\n      season: Number(tv[\"S\"]),\n      yearStart: Number(tv[\"Start\"]),\n      yearEnd: Number(tv[\"End\"]),\n      episodes: Number(tv[\"E\"]),\n      episodeMinutes: parseInt(tv[\"Mins\"]),\n    };\n  }\n\n  static generateSortedTv(tv: Television[]): SortedTv {\n    const sortedTv: SortedTv = {};\n\n    for (let sort of this.sorts) {\n      for (let bool of [true, false]) {\n        sortedTv[`${sort}${bool ? \"Desc\" : \"Asc\"}`] = this.sortTv(\n          [...tv],\n          sort,\n          bool\n        );\n      }\n    }\n\n    return sortedTv;\n  }\n\n  static sortTv(\n    tv: Television[],\n    sortBy: string,\n    isDescending: boolean\n  ): Television[] {\n    let algorithm: ((a: any, b: any) => number) | null = null;\n\n    // title A-Z\n    if (sortBy === \"sortTitle\") {\n      algorithm = (a, b) => a.sortTitle.localeCompare(b.sortTitle);\n      // year 1900-2000 start first season\n    } else if (sortBy === \"yearStart\") {\n      algorithm = (a, b) => a.seasons[0].yearStart - b.seasons[0].yearStart;\n      // year 1900-2000 end last season\n    } else if (sortBy === \"yearEnd\") {\n      algorithm = (a, b) =>\n        a.seasons[a.seasons.length - 1].yearEnd -\n        b.seasons[b.seasons.length - 1].yearEnd;\n      // creator A-Z by last name of first creator\n    } else if (sortBy === \"creator\") {\n      algorithm = (a, b) => {\n        a = a.creator[0].split(/\\s+/).pop();\n        b = b.creator[0].split(/\\s+/).pop();\n        return a.localeCompare(b);\n      };\n    }\n\n    if (!algorithm) return tv;\n\n    // sort ascending\n    let array = [...tv].sort(algorithm);\n\n    // reverse to get descending\n    if (isDescending && this.sorts.includes(sortBy)) {\n      array = array.reverse();\n    }\n\n    return array;\n  }\n}\n","import { Creator } from \"../../classes/Creator\";\nimport { Film } from \"../../classes/Film\";\nimport { Game } from \"../../classes/Game\";\nimport { Television } from \"../../classes/Television\";\nimport filmsJson from \"../../data/films.json\";\nimport gamesJson from \"../../data/games.json\";\nimport tvJson from \"../../data/tv.json\";\nimport { compareLastName } from \"../../utils/utilities\";\n\n// films\nconst films = Film.generateFilmsFromJson(filmsJson).filter(\n  (x, i, a) => a.findIndex((e) => e.name === x.name && e.year === x.year) === i\n);\nconst filmsSorted = Film.generateSortedFilms(films);\n// console.info(\n//   `films.length: ${films.length} filmsSorted: ${Object.keys(filmsSorted)}`\n// );\n\n// film directors\nconst directorsMatrix = films.map((e) => e.creator);\nconst directors = Array.from(new Set(directorsMatrix.flat())).sort(\n  compareLastName\n);\n// console.info(`directors.length: ${directors.length}`);\n\n// tv\nconst tv = Television.generateTvFromJson(tvJson);\nconst tvSorted = Television.generateSortedTv(tv);\n// console.info(`tv.length: ${tv.length} tvSorted: ${Object.keys(tvSorted)}`);\n\n// games\nconst games = Game.generateGamesFromJson(gamesJson).filter(\n  (x, i, a) => a.findIndex((e) => e.name === x.name && e.year === x.year) === i\n);\nconst gamesSorted = Game.generateSortedGames(games);\n// console.info(\n//   `games.length: ${games.length} gamesSorted: ${Object.keys(gamesSorted)}`\n// );\n\n// console.time(\"matrix fiesta\");\nconst tvCreatorsMatrix = tv.map((e) => e.creator);\nconst tvCreators = Array.from(new Set(tvCreatorsMatrix.flat()));\nconst filmAndTvCreators = Array.from(\n  new Set([...directors, ...tvCreators])\n).sort(compareLastName);\n\nconst gameDevelopersMatrix = games.map((e) => e.creator);\nconst gameDevelopers = Array.from(new Set(gameDevelopersMatrix.flat())).sort();\n\nconst creators = Array.from(\n  new Set([...filmAndTvCreators, ...gameDevelopers])\n).map((name) => new Creator(name));\n// console.timeEnd(\"matrix fiesta\");\n\n// console.info(\n//   \"directors\",\n//   directors.length,\n//   \"tvCreators\",\n//   tvCreators.length,\n//   \"filmAndTv\",\n//   filmAndTvCreators.length,\n//   \"gameDevs\",\n//   gameDevelopers.length,\n//   \"all\",\n//   creators.length\n// );\n\nexport const mediaSheet = {\n  films,\n  filmsSorted,\n  directors,\n  tv,\n  tvSorted,\n  games,\n  gamesSorted,\n  creators,\n};\n\nexport type MediaSheet = typeof mediaSheet;\n\n// console.info(`mediaSheet: ${Object.keys(mediaSheet)}`);\n"],"sourceRoot":""}
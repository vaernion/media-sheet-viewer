{"version":3,"sources":["classes/Creator.ts","utils/regex.ts","classes/Film.ts","classes/Game.ts","classes/Television.ts","components/Store/mediaSheet.ts","utils/utilities.ts"],"names":["Creator","name","id","type","this","count","splitRegex","RegExp","Film","film","translatedTitle","sortTitle","creator","genre","year","franchise","split","director","push","trim","Number","filmsJson","map","films","sortedFilms","sorts","sort","bool","sortFilms","sortBy","isDescending","algorithm","a","b","localeCompare","pop","array","includes","reverse","Game","game","completed","system","developer","gamesJson","games","sortedGames","sortGames","Television","tvSeries","seasons","minutesTotal","title","reduce","sum","season","seasonMinutes","tvJson","tvSeasons","parseTvEntry","Array","from","Set","tvSeason","filteredSeasons","filter","rawSeason","yearStart","yearEnd","episodes","episodeMinutes","tv","parseInt","sortedTv","sortTv","length","generateFilmsFromJson","x","i","findIndex","e","filmsSorted","generateSortedFilms","directorsMatrix","directors","flat","compareLastName","generateTvFromJson","tvSorted","generateSortedTv","generateGamesFromJson","gamesSorted","generateSortedGames","tvCreatorsMatrix","tvCreators","filmAndTvCreators","gameDevelopersMatrix","gameDevelopers","creators","filmGenreList","filmGenres","filmYears","genres","tvGenreList","t","tvGenres","tvYears","s","gameGenreList","stats","gameGenres","gameYears","mediaSheet","normalize","str","replace","toLowerCase","arrA","arrB","formatYear","media","isMedia","mediaType","getCreations","cFilms","yearDesc","cTv","yearStartDesc","cGames","capitalizeFirstLetter","string","charAt","toUpperCase","slice"],"mappings":"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","file":"static/js/0.6a0a4625.chunk.js","sourcesContent":["export class Creator {\n  static count: number = 0;\n\n  id: number;\n  type: string;\n  name: string;\n\n  constructor(name: string) {\n    this.id = Creator.count += 1;\n    this.type = \"creator\";\n    this.name = name;\n  }\n}\n","export const splitRegex = new RegExp(/[&,/|]+|\\band\\b/);\n","import { splitRegex } from \"../utils/regex\";\n\ntype FilmJson = {\n  [key: string]: string;\n};\ntype SortedFilms = {\n  [key: string]: Film[];\n};\n\nexport class Film {\n  static count: number = 0;\n  static sorts: string[] = [\"sortTitle\", \"year\", \"director\", \"franchise\"];\n\n  id: number;\n  type: string;\n  name: string;\n  translatedTitle: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  year: number;\n  franchise: string;\n\n  constructor(film: FilmJson) {\n    this.id = Film.count += 1;\n    this.type = \"film\";\n    this.name = film[\"Original title (romanized)\"];\n    this.translatedTitle = film[\"This release's translation/title\"];\n    this.sortTitle = film[\"Sort\"];\n    this.creator = [];\n    for (let director of film[\"Director(s)\"].split(splitRegex)) {\n      this.creator.push(director.trim());\n    }\n    this.genre = [];\n    for (let genre of film[\"Genres\"].split(splitRegex)) {\n      this.genre.push(genre.trim());\n    }\n    this.year = Number(film[\"Year\"]);\n    this.franchise = film[\"Series/Universe\"];\n  }\n\n  static generateFilmsFromJson(filmsJson: FilmJson[]): Film[] {\n    return filmsJson.map((film) => new this(film));\n  }\n\n  static generateSortedFilms(films: Film[]): SortedFilms {\n    const sortedFilms: SortedFilms = {};\n\n    for (let sort of this.sorts) {\n      for (let bool of [true, false]) {\n        sortedFilms[`${sort}${bool ? \"Desc\" : \"Asc\"}`] = this.sortFilms(\n          [...films],\n          sort,\n          bool\n        );\n      }\n    }\n\n    return sortedFilms;\n  }\n\n  static sortFilms(\n    films: Film[],\n    sortBy: string,\n    isDescending: boolean\n  ): Film[] {\n    let algorithm: ((a: any, b: any) => number) | null = null;\n\n    // title A-Z\n    if (sortBy === \"sortTitle\") {\n      algorithm = (a, b) => a.sortTitle.localeCompare(b.sortTitle);\n      // year 1900-2000\n    } else if (sortBy === \"year\") {\n      algorithm = (a, b) => a.year - b.year;\n      // director A-Z by last name of first director\n    } else if (sortBy === \"director\") {\n      algorithm = (a, b) => {\n        a = a.creator[0].split(/\\s+/).pop();\n        b = b.creator[0].split(/\\s+/).pop();\n        return a.localeCompare(b);\n      };\n      // franchise, entries without franchise always last\n    } else if (sortBy === \"franchise\") {\n      // franchise A-Z\n      if (!isDescending) {\n        algorithm = (a, b) => {\n          if (a.franchise === \"\") return 1;\n          if (b.franchise === \"\") return -1;\n          return a.franchise.localeCompare(b.franchise);\n        };\n        // franchise Z-A\n      } else {\n        algorithm = (a, b) => {\n          if (a.franchise === \"\") return 1;\n          if (b.franchise === \"\") return -1;\n          return b.franchise.localeCompare(a.franchise);\n        };\n      }\n    }\n\n    if (!algorithm) return films;\n\n    // sort ascending (and descending if franchise)\n    let array = [...films].sort(algorithm);\n\n    // for all except franchise we can just reverse to get descending\n    if (isDescending && [\"sortTitle\", \"year\", \"director\"].includes(sortBy)) {\n      array = array.reverse();\n    }\n\n    return array;\n  }\n}\n","import { splitRegex } from \"../utils/regex\";\n\ntype GameJson = {\n  [key: string]: string;\n};\ntype SortedGames = {\n  [key: string]: Game[];\n};\n\nexport class Game {\n  static count: number = 0;\n  static sorts: string[] = [\n    \"sortTitle\",\n    \"year\",\n    \"developer\",\n    \"completed\",\n    \"system\",\n  ];\n\n  id: number;\n  type: string;\n  name: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  year: number;\n  completed: string;\n  system: string;\n\n  constructor(game: GameJson) {\n    this.id = Game.count += 1;\n    this.type = \"game\";\n    this.name = game[\"Title\"];\n    this.sortTitle = game[\"Sort\"];\n    this.creator = [];\n    for (let developer of game[\"Developer(s)\"].split(splitRegex)) {\n      this.creator.push(developer.trim());\n    }\n    this.genre = [];\n    for (let genre of game[\"Genres\"].split(splitRegex)) {\n      this.genre.push(genre.trim());\n    }\n    this.year = Number(game[\"Year\"]);\n    this.completed = game[\"completed?\"] || \"no\";\n    this.system = game[\"System\"];\n  }\n\n  static generateGamesFromJson(gamesJson: GameJson[]): Game[] {\n    return gamesJson.map((game) => new this(game));\n  }\n\n  static generateSortedGames(games: Game[]): SortedGames {\n    const sortedGames: SortedGames = {};\n\n    for (let sort of this.sorts) {\n      for (let bool of [true, false]) {\n        sortedGames[`${sort}${bool ? \"Desc\" : \"Asc\"}`] = this.sortGames(\n          [...games],\n          sort,\n          bool\n        );\n      }\n    }\n\n    return sortedGames;\n  }\n\n  static sortGames(\n    games: Game[],\n    sortBy: string,\n    isDescending: boolean\n  ): Game[] {\n    let algorithm: ((a: any, b: any) => number) | null = null;\n\n    // title/completed/system A-Z\n    if (\n      sortBy === \"sortTitle\" ||\n      sortBy === \"completed\" ||\n      sortBy === \"system\"\n    ) {\n      algorithm = (a, b) => a[sortBy].localeCompare(b[sortBy]);\n      // year 1900-2000\n    } else if (sortBy === \"year\") {\n      algorithm = (a, b) => a.year - b.year;\n      // developers A-Z by first dev\n    } else if (sortBy === \"developer\") {\n      algorithm = (a, b) => {\n        a = a.creator[0];\n        b = b.creator[0];\n        return a.localeCompare(b);\n      };\n    }\n\n    if (!algorithm) return games;\n\n    // sort ascending\n    let array = [...games].sort(algorithm);\n\n    // reverse to get descending\n    if (isDescending && this.sorts.includes(sortBy)) {\n      array = array.reverse();\n    }\n\n    return array;\n  }\n}\n","import { splitRegex } from \"../utils/regex\";\n\ntype TvJson = {\n  [key: string]: string;\n};\ntype RawSeason = {\n  title: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  season: number;\n  yearStart: number;\n  yearEnd: number;\n  episodes: number;\n  episodeMinutes: number;\n};\ntype TvSeason = {\n  season: number;\n  yearStart: number;\n  yearEnd: number;\n  episodes: number;\n  episodeMinutes: number;\n  seasonMinutes: number;\n};\ntype TvSeries = {\n  title: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  seasons: TvSeason[];\n};\ntype SortedTv = {\n  [key: string]: Television[];\n};\n\nexport class Television {\n  static count: number = 0;\n  static sorts: string[] = [\"sortTitle\", \"yearStart\", \"yearEnd\", \"creator\"];\n\n  id: number;\n  type: string;\n  name: string;\n  sortTitle: string;\n  creator: string[];\n  genre: string[];\n  seasons: TvSeason[];\n  minutesTotal: number;\n\n  constructor(tvSeries: TvSeries) {\n    this.id = Television.count += 1;\n    this.type = \"tv\";\n    this.name = tvSeries.title;\n    this.sortTitle = tvSeries.sortTitle;\n    this.creator = tvSeries.creator;\n    this.genre = tvSeries.genre;\n    this.seasons = tvSeries.seasons;\n    this.minutesTotal = Number(\n      this.seasons.reduce((sum, season) => sum + season.seasonMinutes, 0)\n    );\n  }\n\n  static generateTvFromJson(tvJson: TvJson[]): Television[] {\n    // every season from json\n    const tvSeasons = tvJson.map(this.parseTvEntry);\n    // unique names of series\n    const tvNames = Array.from(\n      new Set(tvSeasons.map((tvSeason) => tvSeason.title))\n    );\n\n    return tvNames.map((name) => {\n      // seasons of named series\n      let filteredSeasons = tvSeasons.filter(\n        (tvSeason) => tvSeason.title === name\n      );\n\n      // used as class constructor argument\n      let tvSeries: TvSeries = {\n        title: name,\n        sortTitle: filteredSeasons[0].sortTitle,\n        creator: filteredSeasons[0].creator,\n        genre: filteredSeasons[0].genre,\n        seasons: filteredSeasons.map((rawSeason) => ({\n          season: rawSeason.season,\n          yearStart: rawSeason.yearStart,\n          yearEnd: rawSeason.yearEnd,\n          episodes: rawSeason.episodes,\n          episodeMinutes: rawSeason.episodeMinutes,\n          seasonMinutes: rawSeason.episodes * rawSeason.episodeMinutes,\n        })),\n      };\n\n      return new this(tvSeries);\n    });\n  }\n\n  static parseTvEntry(tv: TvJson): RawSeason {\n    return {\n      title: tv[\"Original title\"],\n      sortTitle: tv[\"Sort\"],\n      creator: tv[\"Creator(s)\"].split(splitRegex).map((name) => name.trim()),\n      genre: tv[\"Genres\"].split(splitRegex).map((name) => name.trim()),\n      season: Number(tv[\"S\"]),\n      yearStart: Number(tv[\"Start\"]),\n      yearEnd: Number(tv[\"End\"]),\n      episodes: Number(tv[\"E\"]),\n      episodeMinutes: parseInt(tv[\"Mins\"]),\n    };\n  }\n\n  static generateSortedTv(tv: Television[]): SortedTv {\n    const sortedTv: SortedTv = {};\n\n    for (let sort of this.sorts) {\n      for (let bool of [true, false]) {\n        sortedTv[`${sort}${bool ? \"Desc\" : \"Asc\"}`] = this.sortTv(\n          [...tv],\n          sort,\n          bool\n        );\n      }\n    }\n\n    return sortedTv;\n  }\n\n  static sortTv(\n    tv: Television[],\n    sortBy: string,\n    isDescending: boolean\n  ): Television[] {\n    let algorithm: ((a: any, b: any) => number) | null = null;\n\n    // title A-Z\n    if (sortBy === \"sortTitle\") {\n      algorithm = (a, b) => a.sortTitle.localeCompare(b.sortTitle);\n      // year 1900-2000 start first season\n    } else if (sortBy === \"yearStart\") {\n      algorithm = (a, b) => a.seasons[0].yearStart - b.seasons[0].yearStart;\n      // year 1900-2000 end last season\n    } else if (sortBy === \"yearEnd\") {\n      algorithm = (a, b) =>\n        a.seasons[a.seasons.length - 1].yearEnd -\n        b.seasons[b.seasons.length - 1].yearEnd;\n      // creator A-Z by last name of first creator\n    } else if (sortBy === \"creator\") {\n      algorithm = (a, b) => {\n        a = a.creator[0].split(/\\s+/).pop();\n        b = b.creator[0].split(/\\s+/).pop();\n        return a.localeCompare(b);\n      };\n    }\n\n    if (!algorithm) return tv;\n\n    // sort ascending\n    let array = [...tv].sort(algorithm);\n\n    // reverse to get descending\n    if (isDescending && this.sorts.includes(sortBy)) {\n      array = array.reverse();\n    }\n\n    return array;\n  }\n}\n","import { Creator } from \"../../classes/Creator\";\nimport { Film } from \"../../classes/Film\";\nimport { Game } from \"../../classes/Game\";\nimport { Television } from \"../../classes/Television\";\nimport filmsJson from \"../../data/films.json\";\nimport gamesJson from \"../../data/games.json\";\nimport tvJson from \"../../data/tv.json\";\nimport { compareLastName } from \"../../utils/utilities\";\n\n/* *************\nmediaSheet\n************* */\n\n// films - filtered for uniques\nconst films = Film.generateFilmsFromJson(filmsJson).filter(\n  (x, i, a) => a.findIndex((e) => e.name === x.name && e.year === x.year) === i\n);\nconst filmsSorted = Film.generateSortedFilms(films);\n\n// film directors\nconst directorsMatrix = films.map((e) => e.creator);\nconst directors = Array.from(new Set(directorsMatrix.flat())).sort(\n  compareLastName\n);\n\n// tv\nconst tv = Television.generateTvFromJson(tvJson);\nconst tvSorted = Television.generateSortedTv(tv);\n\n// games - filtered for uniques\nconst games = Game.generateGamesFromJson(gamesJson).filter(\n  (x, i, a) => a.findIndex((e) => e.name === x.name && e.year === x.year) === i\n);\nconst gamesSorted = Game.generateSortedGames(games);\n\n// creators - messy way to collect all unique names (film and tv share many)\nconst tvCreatorsMatrix = tv.map((e) => e.creator);\nconst tvCreators = Array.from(new Set(tvCreatorsMatrix.flat()));\nconst filmAndTvCreators = Array.from(\n  new Set([...directors, ...tvCreators])\n).sort(compareLastName);\n\nconst gameDevelopersMatrix = games.map((e) => e.creator);\nconst gameDevelopers = Array.from(new Set(gameDevelopersMatrix.flat())).sort();\n\nconst creators = Array.from(\n  new Set([...filmAndTvCreators, ...gameDevelopers])\n).map((name) => new Creator(name));\n\n/* *************\nstats\n************* */\n\n// films\nconst filmGenreList = Array.from(\n  new Set(films.map((film) => film.genre).flat())\n).sort();\nconst filmGenres = filmGenreList.map((genre) => ({\n  name: genre,\n  sum: films.filter((film) => film.genre.includes(genre)).length,\n}));\n\nconst filmYearList = Array.from(\n  new Set(films.map((film) => film.year).flat())\n).sort();\nconst filmYears = filmYearList.map((year) => {\n  const genres = filmGenreList.map((genre) => ({\n    name: genre,\n    sum: films.filter(\n      (film) => film.year === year && film.genre.includes(genre)\n    ).length,\n  }));\n  return {\n    year,\n    sum: films.filter((film) => film.year === year).length,\n    genres,\n  };\n});\n\n// tv\nconst tvGenreList = Array.from(new Set(tv.map((t) => t.genre).flat())).sort();\nconst tvGenres = tvGenreList.map((genre) => ({\n  name: genre,\n  sum: tv.filter((t) => t.genre.includes(genre)).length,\n}));\n\nconst tvYearList = Array.from(\n  new Set([\n    ...tv\n      .map((t) => t.seasons)\n      .flat()\n      .map((s) => s.yearStart),\n    ...tv\n      .map((t) => t.seasons)\n      .flat()\n      .map((s) => s.yearEnd),\n  ])\n).sort();\nconst tvYears = tvYearList.map((year) => {\n  const genres = tvGenreList.map((genre) => ({\n    name: genre,\n    sum: tv.filter(\n      (t) =>\n        t.seasons[0].yearStart <= year &&\n        t.seasons[t.seasons.length - 1].yearEnd >= year &&\n        t.genre.includes(genre)\n    ).length,\n  }));\n  return {\n    year,\n    sum: tv.filter(\n      (t) =>\n        t.seasons[0].yearStart <= year &&\n        t.seasons[t.seasons.length - 1].yearEnd >= year\n    ).length,\n    genres,\n  };\n});\n\n// games\nconst gameGenreList = Array.from(\n  new Set(games.map((game) => game.genre).flat())\n).sort();\nconst gameGenres = gameGenreList.map((genre) => ({\n  name: genre,\n  sum: games.filter((game) => game.genre.includes(genre)).length,\n}));\n\nconst gameYearList = Array.from(\n  new Set(games.map((game) => game.year).flat())\n).sort();\nconst gameYears = gameYearList.map((year) => {\n  const genres = gameGenreList.map((genre) => ({\n    name: genre,\n    sum: games.filter(\n      (game) => game.year === year && game.genre.includes(genre)\n    ).length,\n  }));\n  return {\n    year,\n    sum: games.filter((game) => game.year === year).length,\n    genres,\n  };\n});\n\n/* *************\nexport\n************* */\n\nexport const stats = {\n  filmGenres,\n  filmYears,\n  tvGenres,\n  tvYears,\n  gameGenres,\n  gameYears,\n};\n\nexport const mediaSheet = {\n  films,\n  filmsSorted,\n  directors,\n  tv,\n  tvSorted,\n  games,\n  gamesSorted,\n  creators,\n  filmGenres: filmGenreList,\n};\n\nexport type MediaSheet = typeof mediaSheet;\n","import { Creator } from \"../classes/Creator\";\nimport { Film } from \"../classes/Film\";\nimport { Game } from \"../classes/Game\";\nimport { Television } from \"../classes/Television\";\nimport { MediaSheet } from \"../components/Store/mediaSheet\";\n\nexport const normalize = (str: string) => {\n  return str\n    .normalize(\"NFD\")\n    .replace(/[^\\w\\s.-_/]/g, \"\")\n    .toLowerCase();\n};\n\nexport const compareLastName = (a: string, b: string) => {\n  const arrA = a.split(/\\s+/);\n  const arrB = b.split(/\\s+/);\n  a = arrA[arrA.length - 1];\n  b = arrB[arrB.length - 1];\n  return a.localeCompare(b);\n};\n\nexport const formatYear = (media: Film | Television | Game | Creator) => {\n  if (media.type === \"tv\" && \"seasons\" in media) {\n    return `(${media.seasons[0].yearStart}-${\n      media.seasons[media.seasons.length - 1].yearEnd\n    })`;\n  } else if (\"year\" in media) {\n    return `(${media.year})`;\n  } else {\n    return null;\n  }\n};\n\nexport const isMedia = (mediaType: string) => {\n  return mediaType !== \"creator\";\n};\n\nexport const getCreations = (name: string, mediaSheet: MediaSheet) => {\n  let cFilms = mediaSheet.filmsSorted.yearDesc.filter((e) =>\n    e.creator.includes(name)\n  );\n  let cTv = mediaSheet.tvSorted.yearStartDesc.filter((e) =>\n    e.creator.includes(name)\n  );\n  let cGames = mediaSheet.gamesSorted.yearDesc.filter((e) =>\n    e.creator.includes(name)\n  );\n  return [...cFilms, ...cTv, ...cGames];\n};\n\nexport const capitalizeFirstLetter = (string: string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n"],"sourceRoot":""}